<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一纸墨迹</title>
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://benvim.github.io/"/>
  <updated>2016-03-25T15:06:15.000Z</updated>
  <id>http://benvim.github.io/</id>
  
  <author>
    <name>Ben</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS 实现上下滚动文字</title>
    <link href="http://benvim.github.io/2016/03/25/js-scroll-text/"/>
    <id>http://benvim.github.io/2016/03/25/js-scroll-text/</id>
    <published>2016-03-25T14:45:23.000Z</published>
    <updated>2016-03-25T15:06:15.000Z</updated>
    
    <content type="html">&lt;p&gt;网站实现JS上下滚动文本。这种东西经常会要，所以写个小组件用用，轻量级的。js原生和jquery混搭实现，jquery实在太方便了。&lt;/p&gt;
&lt;h3 id=&quot;一、组件初始化&quot;&gt;&lt;a href=&quot;#一、组件初始化&quot; class=&quot;headerlink&quot; title=&quot;一、组件初始化&quot;&gt;&lt;/a&gt;一、组件初始化&lt;/h3&gt;&lt;p&gt;初始化组件的参数说明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rollObj.init = function(_containerName, _showNum, _timeInterval, _listHeight, _animateSpeed);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;_containerName 容器的ID&lt;/li&gt;
&lt;li&gt;_showNum 显示几行&lt;/li&gt;
&lt;li&gt;_timeInterval 每次移动的触发时间（单位毫秒）&lt;/li&gt;
&lt;li&gt;_listHeight 每li的高度，也可理解为每次移动的高度。&lt;/li&gt;
&lt;li&gt;_animateSpeed 动画执行的速度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;二、html的结构说明&quot;&gt;&lt;a href=&quot;#二、html的结构说明&quot; class=&quot;headerlink&quot; title=&quot;二、html的结构说明&quot;&gt;&lt;/a&gt;二、html的结构说明&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div class=&amp;quot;notice_task&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;ul class=&amp;quot;notice_task_container&amp;quot; id=&amp;quot;notice_task_container_id&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;lt;li&amp;gt;&amp;lt;a class=&amp;quot;&amp;quot; href=&amp;quot;#&amp;quot; title=&amp;quot;&amp;#123;$notic.title&amp;#125;&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;#123;$notic.title&amp;#125;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;lt;li&amp;gt;&amp;lt;a class=&amp;quot;&amp;quot; href=&amp;quot;#&amp;quot; title=&amp;quot;&amp;#123;$notic.title&amp;#125;&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;#123;$notic.title&amp;#125;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;lt;li&amp;gt;&amp;lt;a class=&amp;quot;&amp;quot; href=&amp;quot;#&amp;quot; title=&amp;quot;&amp;#123;$notic.title&amp;#125;&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;#123;$notic.title&amp;#125;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;/ul&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;notice_task&lt;/em&gt; 为最外层容器，css样式要设置为&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;relative;``` 其子元素 *notice_task_container* 的css样式也要设置为 ```position:relative;``` 这样才可以控制 *notice_task_container_id*容器的top属性使其移动。&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 三、JS代码使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用也很简单，```rollTextControl.createObj();``` 创建组件，初始化基本参数即可。使用```$(function()&amp;#123;&amp;#125;```包裹起来是保证页面加载完成后再调用该部分代码。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(function(){
    var notic = rollTextControl.createObj();
   notic.init(&amp;quot;notice_task_container_id&amp;quot;, 3, 3000, -40, 1000);
});
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;这样就可以了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 四、组件源代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有空再优化和整理，暂且这样吧。代码比较简，看看就明白了。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;var rollTextControl = {&lt;br&gt;　　　　createObj: function(){&lt;br&gt;            var rollObj = {};&lt;br&gt;            var containerName = null; //列表的容器。用于删除，和创建子对象&lt;br&gt;            var showNum = 1; //显示的数量&lt;br&gt;            var timeInterval = 1000;//间隔1秒操作一次。&lt;br&gt;            var rollData = null;//列表数据&lt;br&gt;            var dataLen = 0;&lt;br&gt;            var listHeight = -32;&lt;br&gt;            var indexID = 0;&lt;br&gt;            var animateSpeed = 1000;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    rollObj.init = function(_containerName, _showNum, _timeInterval, _listHeight, _animateSpeed){
        containerName   =  _containerName;
        showNum         = _showNum;
        timeInterval    = _timeInterval;
        animateSpeed    = _animateSpeed;
        listHeight      = _listHeight;
        onGetData();
    }

    function onGetData(){
        var element = document.getElementById(containerName);
        rollData = [];
        if(element){
            while(element.hasChildNodes()) {
                var obj = element.removeChild(element.firstChild).cloneNode(true);
                if(obj){
                    var str = obj.tagName;
                    if(str)str=str.toLocaleLowerCase();
                    if(str==&amp;quot;li&amp;quot;) rollData.push(obj); 
                }   
            }
        }
        if(rollData!=null) startGo();
    }

    function startGo(){
        dataLen = rollData.length;
        for (var i = 0; i &amp;lt; showNum; i++) {
            var data = rollData[i];
            if(data) createView(data);
        }
        indexID = showNum-1;
        if(dataLen&amp;gt;showNum) timer();
    }

    function timer(){
        setInterval(rollUpdate, timeInterval);
    }

    function rollUpdate(argument) {
        getNextData();
        var element = document.getElementById(containerName);
        if(element.hasChildNodes()){
            firstChild = element.firstChild;
            $(&amp;quot;#&amp;quot;+containerName).animate({&amp;apos;top&amp;apos;:listHeight}, animateSpeed,animateComplete);    
        }
    }

    function animateComplete(){
        //动画完成后，删除最顶上的内容，并重设置容器坐标。
        var firstChild = null;
        var element = document.getElementById(containerName);
        if(element.hasChildNodes() &amp;amp;&amp;amp; element.children.length&amp;gt;showNum){
            firstChild = element.firstChild;
            if(firstChild)
                element.removeChild(element.firstChild);    
        }else{
            //console.log(&amp;quot;faild&amp;quot; + element.children.length);
        }

        $(&amp;quot;#&amp;quot;+containerName).css({&amp;apos;top&amp;apos;:0});
    }

    function createView(data){
        $(&amp;quot;#&amp;quot;+containerName).append(data);
    }

    function getNextData(){
        if(indexID &amp;lt; dataLen){
            indexID++;
        }else{
            indexID = 0;
        }
        var data  = rollData[indexID];
        if(data) createView(data);
    }
    return rollObj;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;$(function(){&lt;br&gt;    var roll = rollTextControl.createObj();&lt;br&gt;    roll.init(“employListContainer”, 6, 2000, -32, 1000);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var notic = rollTextControl.createObj();
notic.init(&amp;quot;notice_task_container_id&amp;quot;, 3, 3000, -40, 1000);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;网站实现JS上下滚动文本。这种东西经常会要，所以写个小组件用用，轻量级的。js原生和jquery混搭实现，jquery实在太方便了。&lt;/p&gt;
&lt;h3 id=&quot;一、组件初始化&quot;&gt;&lt;a href=&quot;#一、组件初始化&quot; class=&quot;headerlink&quot; title=&quot;一、组件
    
    </summary>
    
      <category term="js" scheme="http://benvim.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://benvim.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS的call()方法、apply()与 bind()方法详解</title>
    <link href="http://benvim.github.io/2016/03/23/js-call-apply-bind/"/>
    <id>http://benvim.github.io/2016/03/23/js-call-apply-bind/</id>
    <published>2016-03-23T06:34:22.000Z</published>
    <updated>2016-03-24T01:05:28.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-call是函数的函数，用来改变函数作用域的。&quot;&gt;&lt;a href=&quot;#1-call是函数的函数，用来改变函数作用域的。&quot; class=&quot;headerlink&quot; title=&quot;1.call是函数的函数，用来改变函数作用域的。&quot;&gt;&lt;/a&gt;1.call是函数的函数，用来改变函数作用域的。&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/uploads/110.jpg&quot; alt=&quot;call是函数的函数&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过fun()的方法调用，他的作用域是全局的，我可以通过call改变fun的作用域。让他的this对应到obj上，因为本身在fun()定义和外面的全局域里都没有定义变量 a 。是不是感觉像是给obj增加了fun()方法？其实不是的，obj还是没有fun这个方法，在调用fun的时候，把this变成了obj，所以那句&lt;code&gt;console.log(this.a)&lt;/code&gt;你可以理解成&lt;code&gt;console.log(obj.a);&lt;/code&gt;。 &lt;/p&gt;
&lt;h3 id=&quot;2-为什么要用call方法，或者说call方法的使用动机是什么？&quot;&gt;&lt;a href=&quot;#2-为什么要用call方法，或者说call方法的使用动机是什么？&quot; class=&quot;headerlink&quot; title=&quot;2.为什么要用call方法，或者说call方法的使用动机是什么？&quot;&gt;&lt;/a&gt;2.为什么要用call方法，或者说call方法的使用动机是什么？&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/uploads/112.jpg&quot; alt=&quot;call是函数的函数&quot;&gt;&lt;/p&gt;
&lt;p&gt;看上图的输出，这个就是它的用途了，方法的this对象是什么其实是看你有没有在对象上调用方法。如果在 &lt;code&gt;obj.fun()&lt;/code&gt;上调用就是那个obj，如果把&lt;code&gt;obj.fun&lt;/code&gt;赋值给一个变量，因为没有用。去调用，所以他的this指向了window，比如你把一个对象的fun作为回调传到另外一个方法里去，它的this对象就会丢失，变成了指向window的对象，就失去了原本回调的意义。 &lt;strong&gt;所以这个时候就需要把obj对象也一并传到另外一个方法里通过fun.call(obj)去调用，确保他的作用域还是那个obj&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-call和apply方法的区别&quot;&gt;&lt;a href=&quot;#3-call和apply方法的区别&quot; class=&quot;headerlink&quot; title=&quot;3.call和apply方法的区别&quot;&gt;&lt;/a&gt;3.call和apply方法的区别&lt;/h3&gt;&lt;p&gt;call和apply其实非常像，只是在传入 &lt;strong&gt;参数时有差别&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/113.jpg&quot; alt=&quot;call是函数的函数&quot;&gt;&lt;/p&gt;
&lt;p&gt;call是像我们常规调用参数那样，一个一个的传入进去，而apply就是把参数变成一个数组传进去，仅此而已。&lt;/p&gt;
&lt;h3 id=&quot;4-bind方法的区别&quot;&gt;&lt;a href=&quot;#4-bind方法的区别&quot; class=&quot;headerlink&quot; title=&quot;4.bind方法的区别&quot;&gt;&lt;/a&gt;4.bind方法的区别&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/uploads/114.jpg&quot; alt=&quot;call是函数的函数&quot;&gt;&lt;/p&gt;
&lt;p&gt;bind的区别是这样的，也可以改变作用域，但是他会返回一个新的函数，但是你也可以在bind的时候强制使用指定的参数，在调用的时候它就会用bind指定的那个参数了。如果你只是&lt;code&gt;fun.bind(this)&lt;/code&gt;的话，那返回的那个newFun不管你怎么调用，它的作用域都是bind传进去的第一个参数，相当是干涉了参数的值，如果在bind不传入任何的参数，调用还是会用传入的参数。&lt;/p&gt;
&lt;p&gt;参考文献:&lt;a href=&quot;http://bonsaiden.github.io/JavaScript-Garden/zh/#object.prototype&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javascript高级特性&lt;/a&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javascript新的版本&lt;/a&gt; &lt;a href=&quot;http://javascript.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript 标准参考教程&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-call是函数的函数，用来改变函数作用域的。&quot;&gt;&lt;a href=&quot;#1-call是函数的函数，用来改变函数作用域的。&quot; class=&quot;headerlink&quot; title=&quot;1.call是函数的函数，用来改变函数作用域的。&quot;&gt;&lt;/a&gt;1.call是函数的函数，用
    
    </summary>
    
      <category term="js" scheme="http://benvim.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://benvim.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>添加CND后的验证码错误问题及其解决方案</title>
    <link href="http://benvim.github.io/2016/03/22/php-cdn/"/>
    <id>http://benvim.github.io/2016/03/22/php-cdn/</id>
    <published>2016-03-22T12:15:00.000Z</published>
    <updated>2016-03-22T13:23:12.000Z</updated>
    
    <content type="html">&lt;p&gt;网站为了提高各地的访问速度，都会使用CDN以增加缓存结点，来提高用户打开网站的速度，但是缓存节点会造成验证码偶然错误的情况。由于问题隐蔽性不容易被发现，在本地测试和未使用CDN的情况下是正常的。使用CDN后也不会立即出现，只是部分用户出现异常，所以很难发现。&lt;/p&gt;
&lt;h5 id=&quot;1-问题现像&quot;&gt;&lt;a href=&quot;#1-问题现像&quot; class=&quot;headerlink&quot; title=&quot;1.问题现像&quot;&gt;&lt;/a&gt;1.问题现像&lt;/h5&gt;&lt;p&gt;今天网站突然所有需要验证码的地方都提示验证码错误无法操作。开始以为是centos服务器的session不能写入了，查看了session目录，权限正常，能正常写入session。重启服务器，问题依然存在。&lt;/p&gt;
&lt;h5 id=&quot;2-排查问题&quot;&gt;&lt;a href=&quot;#2-排查问题&quot; class=&quot;headerlink&quot; title=&quot;2.排查问题&quot;&gt;&lt;/a&gt;2.排查问题&lt;/h5&gt;&lt;p&gt;发现每次验证码请求一次，在服务端的session却被写了2次或3次。修改session写入代码。&lt;code&gt;$_SERVER[&amp;#39;HTTP_X_FORWARDED_FOR&amp;#39;]&lt;/code&gt; 获取用户的IP地址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session(&amp;apos;captcha&amp;apos;.$_SERVER[&amp;apos;HTTP_X_RORWARDED_FOR&amp;apos;], md5($code));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看session文件写入内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;captcha122.228.74.137|s:32:&amp;quot;d465f14a648b3d0a1faa6f447e526c60&amp;quot;;captcha183.155.217.251|s:32:&amp;quot;e069ea4c9c233d36ff9c7f329bc08ff1&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一次刷新请求，有多个IP请求并生成session，本地的ip:183.115.217.251.另外的IP则应该是CDN缓存服务器的IP地址。所以这是造成验证码不一致的根本原因。&lt;/p&gt;
&lt;h5 id=&quot;3-解决办法&quot;&gt;&lt;a href=&quot;#3-解决办法&quot; class=&quot;headerlink&quot; title=&quot;3.解决办法&quot;&gt;&lt;/a&gt;3.解决办法&lt;/h5&gt;&lt;p&gt;给验证码生成的部分写入session位置增加IP地址的has值。如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session(&amp;apos;captcha&amp;apos;.md5($_SERVER[&amp;apos;HTTP_X_FORWARDED_FOR&amp;apos;]), md5($code));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;验证部分，取出写入的session. 其中&lt;code&gt;getIPAderss()&lt;/code&gt;方法是获取本地IP的方法，这样取出同一个验证码，保证服务端的session验证码记录和填写的验证码一致。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(session(&amp;apos;captcha&amp;apos;.md5(getIPAderss())) != md5($captcha)){
    ....
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;了解问题产生的根本原因后，解决办法还是比较容易的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;网站为了提高各地的访问速度，都会使用CDN以增加缓存结点，来提高用户打开网站的速度，但是缓存节点会造成验证码偶然错误的情况。由于问题隐蔽性不容易被发现，在本地测试和未使用CDN的情况下是正常的。使用CDN后也不会立即出现，只是部分用户出现异常，所以很难发现。&lt;/p&gt;
&lt;h5
    
    </summary>
    
      <category term="php" scheme="http://benvim.github.io/categories/php/"/>
    
    
      <category term="php" scheme="http://benvim.github.io/tags/php/"/>
    
      <category term="cdn" scheme="http://benvim.github.io/tags/cdn/"/>
    
      <category term="验证码" scheme="http://benvim.github.io/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>如何更快的学习</title>
    <link href="http://benvim.github.io/2016/03/21/method-learn/"/>
    <id>http://benvim.github.io/2016/03/21/method-learn/</id>
    <published>2016-03-21T01:20:23.000Z</published>
    <updated>2016-03-21T01:32:31.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;钻研（The-Drilldown-Method-使用你学得更快&quot;&gt;&lt;a href=&quot;#钻研（The-Drilldown-Method-使用你学得更快&quot; class=&quot;headerlink&quot; title=&quot;钻研（The Drilldown Method):使用你学得更快&quot;&gt;&lt;/a&gt;钻研（The Drilldown Method):使用你学得更快&lt;/h4&gt;&lt;p&gt;经年累月，我完善了一个方法，可以加速逐层增进理解的过程。这个方法至今已被我用于各科目的课题，包括数学、生物学、物理学、经济学与工程学。只需些许修改，它对掌握实用技能也效果很好，比如编程、设计或语言。这个方法的基本结构是：知识面、练习、自省。我将解释每个阶段，让你了解如何尽可能有效率地执行它们，同时给出详细的例子，展示我是怎么应用在实际课程的。&lt;/p&gt;
&lt;h4 id=&quot;第一阶段：-知识面覆盖&quot;&gt;&lt;a href=&quot;#第一阶段：-知识面覆盖&quot; class=&quot;headerlink&quot; title=&quot;第一阶段： 知识面覆盖&quot;&gt;&lt;/a&gt;第一阶段： 知识面覆盖&lt;/h4&gt;&lt;p&gt;你不可能组织一场进攻，如果你连一张地形图都没有。因此，深入研习的第一步，就是对你需要学习的内容有个大致印象。若在课堂上，这意味着你要看讲义或读课本；若是自学，你可能要多读几本同主题的书，相互考证。&lt;/p&gt;
&lt;p&gt;学生们常犯的一个错误，就是认为这个阶段是最重要的。从很多方面来讲，这个阶段却是效率最低的，因为你每单位时间的投入只换来了最少量的知识回报。我常常加速完成这个阶段，很有好处，这样，我就可以投入更多时间到后面两个阶段。&lt;/p&gt;
&lt;p&gt;如果你在看课程讲座的视频，最好是调到1.5x或2x倍速快进。这很容易做到，只要你下载好视频，然后使用播放器（如VLC）的“调速”功能。我用这法子两天内看完了一学期的课程视频。如果你在读一本书，我建议你不要花时间去高亮文本。这样只会让你的知识理解停留在低层次，而从长远来看，也使学习效率低下。更好的方法是，阅读时只偶尔做做笔记，或在读过每个主要章节后写一段落的总结。&lt;/p&gt;
&lt;p&gt;这里有个&lt;a href=&quot;http://www.scotthyoung.com/mit/machine-vision-notes.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;例子&lt;/a&gt;，是我上机器视觉这门课时的笔记。&lt;/p&gt;
&lt;h4 id=&quot;第二阶段：练习&quot;&gt;&lt;a href=&quot;#第二阶段：练习&quot; class=&quot;headerlink&quot; title=&quot;第二阶段：练习&quot;&gt;&lt;/a&gt;第二阶段：练习&lt;/h4&gt;&lt;p&gt;做练习题，能极大地促进你的知识理解。但是，如果你不小心，可能会落入两个效率陷阱：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有获得即时的反馈：研究表明，如果你想更好地学习，你需要即时的反馈。因此，做题时最好是答案在手，天下我有，每做完一题就对答案，自我审查。没有反馈或反馈迟来的练习，只会严重牵制学习效率；&lt;/li&gt;
&lt;li&gt;题海战术：正如有人以为学习是始于教室终于教室，一些学生也认为大多数的知识理解产自练习题。是的，你总能通过题海战术最终搭起知识框架，但过程缓慢、效率低下。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;练习题，应该能凸显你需要建立更好直觉的知识领域。一些技巧，比如我将会谈到的费曼技巧（the Feynman technique），对此则相当有效。对于非技术类学科，它更多的是要求你掌握概念而不是解决问题，所以，你常常只需要完成最少量的习题。对这些科目，你最好花更多的时间在第三阶段，形成学科的洞察力。&lt;/p&gt;
&lt;h3 id=&quot;第三阶段：自省&quot;&gt;&lt;a href=&quot;#第三阶段：自省&quot; class=&quot;headerlink&quot; title=&quot;第三阶段：自省&quot;&gt;&lt;/a&gt;第三阶段：自省&lt;/h3&gt;&lt;p&gt;知识面覆盖，与做练习题，是为了让你知道你还有什么不懂。这并不像听上去那么容易，毕竟知之为知之，不知为不知，难矣。你以为你都懂了，其实不是，所以老犯错；或者，你对某综合性学科心里没底，但又看不确切还有哪里不懂。&lt;/p&gt;
&lt;p&gt;接下来的技巧，我称之为“费曼技巧”，将帮助你查漏补缺，在求知路上走得更远。当你能准确识别出你不懂的知识点时，这个技巧助你填补知识的缺口，尤其是那些最难以填补的巨大缺口。这个技巧还能两用。即使你真的理解了某个想法，它也能让你关联更多的想法，于是，你可以继续钻研，深化理解。&lt;/p&gt;
&lt;h3 id=&quot;费曼技巧（The-Feynman-Technique）&quot;&gt;&lt;a href=&quot;#费曼技巧（The-Feynman-Technique）&quot; class=&quot;headerlink&quot; title=&quot;费曼技巧（The Feynman Technique）&quot;&gt;&lt;/a&gt;费曼技巧（The Feynman Technique）&lt;/h3&gt;&lt;p&gt;这个技巧的灵感，源于诺贝尔物理奖获得者，理查德·费曼（Richard Feynman）。在他的自传里，他提到曾纠结于某篇艰深的研究论文。他的办法是，仔细审阅这篇论文的辅助材料（supporting material），直到他掌握了相关的知识基础、足以理解其中的艰深想法为止。&lt;/p&gt;
&lt;p&gt;费曼技巧，亦同此理。对付一个知识枝节繁杂如发丝、富有内涵的想法，应该分而化之，切成小知识块，再逐个对付，你最终能填补所有的知识缺口，否则，这些缺口将阻挠你理解这个想法。对此，&lt;a href=&quot;https://www.youtube.com/watch?v=FrNqSLPaZLc&amp;amp;feature=youtu.be&amp;amp;t=1m17s&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;请看这个简短的教程视频&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;费曼技巧很简单：&quot;&gt;&lt;a href=&quot;#费曼技巧很简单：&quot; class=&quot;headerlink&quot; title=&quot;费曼技巧很简单：&quot;&gt;&lt;/a&gt;费曼技巧很简单：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;拿张白纸；&lt;/li&gt;
&lt;li&gt;在白纸顶部写上你想理解的某想法或某过程 &lt;/li&gt;
&lt;li&gt;用你自己的话解释它，就像你在教给别人这个想法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;最要紧的是，对一个想法分而化之，虽然可能重复解释某些已经弄懂的知识点。&lt;/em&gt; 但你最终会到达一个临界点，无法再解释清楚。那里正是你需要填补的知识缺口。为了填补这个缺口，你可以查课本、问老师、或到互联网搜寻答案。通常来说，一旦你精准地定义了你的不解或误解，找到确切的答案则相对而言更轻松。&lt;/p&gt;
&lt;p&gt;我已经使用过这个费曼技巧有数百次，确信它能应付各种各样的学习情境。然而，由于学习情境各有特点，它需要灵活变通，似乎显得难以入门，所以，我将尝试举些不同的例子。&lt;/p&gt;
&lt;h5 id=&quot;1-对付你完全摸不着头脑的概念&quot;&gt;&lt;a href=&quot;#1-对付你完全摸不着头脑的概念&quot; class=&quot;headerlink&quot; title=&quot;1.对付你完全摸不着头脑的概念&quot;&gt;&lt;/a&gt;1.对付你完全摸不着头脑的概念&lt;/h5&gt;&lt;p&gt;对此，我仍坚持使用费曼技巧，但翻开课本，找到解释这个概念的章节。我先浏览一遍作者的解释，然后仔细地摹仿它，并也试着用自己的思维详述和阐明它。如此一来，当你不能用自己的话写下任何解释时，“引导式”费曼技巧很有用处。这里有个&lt;a href=&quot;http://www.scotthyoung.com/mit/photogrammetry.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;例子&lt;/a&gt;，展示我如何理解摄影测量学。&lt;/p&gt;
&lt;h5 id=&quot;2-对付各种过程&quot;&gt;&lt;a href=&quot;#2-对付各种过程&quot; class=&quot;headerlink&quot; title=&quot;2.对付各种过程&quot;&gt;&lt;/a&gt;2.对付各种过程&lt;/h5&gt;&lt;p&gt;你也能通过费曼技巧去了解一个你需要用到的过程。审视所有的步骤，不光解释每一步在干什么，还要清楚它是怎么执行的。我常这样理解数学的证明过程、化学的方程式、与生物学的糖酵解过程。这里有个&lt;a href=&quot;http://www.scotthyoung.com/mit/grid-accel.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;例子&lt;/a&gt;，展示我如何想到怎么实现网格加速。&lt;/p&gt;
&lt;h5 id=&quot;3-对付各种公式&quot;&gt;&lt;a href=&quot;#3-对付各种公式&quot; class=&quot;headerlink&quot; title=&quot;3.对付各种公式&quot;&gt;&lt;/a&gt;3.对付各种公式&lt;/h5&gt;&lt;p&gt;公式，应该被理解，而不只是死记硬背。因此，当你看到一个公式，却无法理解它的运作机理时，试着用费曼技巧分而化之。这里有个&lt;a href=&quot;http://www.scotthyoung.com/mit/fourier.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;例子&lt;/a&gt;，展示我如何理解傅里叶分析方程。&lt;/p&gt;
&lt;h5 id=&quot;4-对付需要记忆的内容&quot;&gt;&lt;a href=&quot;#4-对付需要记忆的内容&quot; class=&quot;headerlink&quot; title=&quot;4.对付需要记忆的内容&quot;&gt;&lt;/a&gt;4.对付需要记忆的内容&lt;/h5&gt;&lt;p&gt;费曼技巧，也可以帮你自查是否掌握非技术类学科那些博大精深的知识概念。对于某个主题，如果你能顺利应用费曼技巧，而无需参考原始材料（讲义、课本等），就证明你已经理解和记住它。。这里有个&lt;a href=&quot;http://www.scotthyoung.com/mit/predatory-pricing.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;例子&lt;/a&gt;，展示我如何回忆起经济学中的掠夺性定价概念。&lt;/p&gt;
&lt;h4 id=&quot;形成更深刻的直觉（Deeper-Intuition）&quot;&gt;&lt;a href=&quot;#形成更深刻的直觉（Deeper-Intuition）&quot; class=&quot;headerlink&quot; title=&quot;形成更深刻的直觉（Deeper Intuition）&quot;&gt;&lt;/a&gt;形成更深刻的直觉（Deeper Intuition）&lt;/h4&gt;&lt;p&gt;结合做习题，费曼技巧能帮你剥开知识理解的浅层表皮。但它也能帮你钻研下去，走得更远，不只是浅层的理解，而是形成深刻的知识直觉。直观地理解一个想法，并非易事。它看似有些许神秘，但这不是它的本相。一个想法的多数直觉，可作以下归类。&lt;/p&gt;
&lt;h5 id=&quot;1-类比、可视化、简化&quot;&gt;&lt;a href=&quot;#1-类比、可视化、简化&quot; class=&quot;headerlink&quot; title=&quot;1.类比、可视化、简化&quot;&gt;&lt;/a&gt;1.类比、可视化、简化&lt;/h5&gt;&lt;p&gt;类比：你理解一个想法，是通过确认它与某个更易理解的想法之间的重要相似点；可视化：抽象概念也常成为有用的直觉，只要我们能在脑海为它们构筑画面，即使这个画面只是一个更大更多样化想法的不完全表达；简化：一位著名的科学家曾说过，如果你不能给你的祖母解释一样东西，说明你还没有完全理解它。简化是一门艺术，它加强了基础概念与复杂想法之间的思维联系。&lt;/p&gt;
&lt;p&gt;你可以用费曼技巧去激发这些直觉。对于某个想法，一旦你有了大致的理解，下一步就是深入分析，看能不能用以上三种直觉来阐释它。期间，就算是借用已有的意象喻义，也是情有可原的。例如，把复数放到二维空间里理解，很难称得上是新颖的，但它能让你很好地可视化这个概念，让概念在脑海中构图成型。DNA复制，被想象成拉开一条单向拉链，这也不是一个完美的类比，但只要你心里清楚其中的异同，它会变得有用。&lt;/p&gt;
&lt;h5 id=&quot;2-学得更快的策略&quot;&gt;&lt;a href=&quot;#2-学得更快的策略&quot; class=&quot;headerlink&quot; title=&quot;2.学得更快的策略&quot;&gt;&lt;/a&gt;2.学得更快的策略&lt;/h5&gt;&lt;p&gt;在这篇文章里，我描述了学习的三个阶段：知识面、练习、与自省。但这可能让你误解，错以为它们总在不同的时期被各自执行，从不重叠或反复。实际上，随着不断地深入理解知识，你可能会周而复始地经历这些阶段。你刚开始读一个章节，只能有个大概的肤浅印象，但做过练习题和建立了直觉以后，你再回过来重新阅读，又会有更深刻的理解，即温故而知新。&lt;/p&gt;
&lt;h5 id=&quot;3-钻研吧，即便你不是学生&quot;&gt;&lt;a href=&quot;#3-钻研吧，即便你不是学生&quot; class=&quot;headerlink&quot; title=&quot;3.钻研吧，即便你不是学生&quot;&gt;&lt;/a&gt;3.钻研吧，即便你不是学生&lt;/h5&gt;&lt;p&gt;这个过程不只是适用于学生，也同样有助于学习复杂技能或积累某话题的专业知识。学习像编程或设计的技能，大多数人遵循前两个阶段。他们阅读一本相关的基础书籍，然后在一个项目里历练。然而，你能运用费曼技巧更进一步，更好地锁定与清晰表述你的深刻见解。积累某话题的专业知识，亦同此理；唯一的差别是，你在建立知识面以前，需要搜集一些学习材料，包括相关的研究文章、书籍等。无论如何，只要你弄清楚了想掌握的知识领域，你就钻研下去，深入学习它。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://calnewport.com/blog/2012/10/26/mastering-linear-algebra-in-10-days-astounding-experiments-in-ultra-learning/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文来自&lt;/a&gt; &lt;a href=&quot;http://calnewport.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CAL NEWPORT&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;钻研（The-Drilldown-Method-使用你学得更快&quot;&gt;&lt;a href=&quot;#钻研（The-Drilldown-Method-使用你学得更快&quot; class=&quot;headerlink&quot; title=&quot;钻研（The Drilldown Method):使用你学得
    
    </summary>
    
      <category term="method" scheme="http://benvim.github.io/categories/method/"/>
    
    
      <category term="method" scheme="http://benvim.github.io/tags/method/"/>
    
      <category term="learn" scheme="http://benvim.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>MAC OS X系统下编写汇编 assembly language</title>
    <link href="http://benvim.github.io/2016/03/20/assembly/"/>
    <id>http://benvim.github.io/2016/03/20/assembly/</id>
    <published>2016-03-20T12:44:53.000Z</published>
    <updated>2016-03-20T12:58:34.000Z</updated>
    
    <content type="html">&lt;p&gt;汇编语言（assembly language)：介于机器语言与C语言之间的一种低级语言。书写风格分为windows/dos常用的intel风格和UNIX的AT&amp;amp;T风格。&lt;/p&gt;
&lt;p&gt;mac 下的汇编代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_syscall:               # declaring a kernel call function &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int      $0x80      # make the system call &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ret                 # return to the caller  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_print_info_s:          # entry point for linker &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pushl    $len       # message length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pushl    $msg       # message to write&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pushl    $0x1       # file descriptor value &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    movl     $0x4, %eax # system call number (sys_write) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    call     _syscall   # call the kernel &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addl     $12, %esp  # clean the stack&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ret&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参数传递:linux主要是靠寄存器，而 BSD 主要靠堆栈。&lt;br&gt;在Xcode里如果需要使用 Intel 风格的代码，请将扩展名改成 .nasm，如果是 AT&amp;amp;T ，那么.s 即可。要在 C 代码里调用汇编写的函数，请在汇编里用 global (.globl) 导出符号&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;汇编语言（assembly language)：介于机器语言与C语言之间的一种低级语言。书写风格分为windows/dos常用的intel风格和UNIX的AT&amp;amp;T风格。&lt;/p&gt;
&lt;p&gt;mac 下的汇编代码：&lt;/p&gt;
&lt;figure class=&quot;highlight 
    
    </summary>
    
      <category term="assembly" scheme="http://benvim.github.io/categories/assembly/"/>
    
    
      <category term="assembly" scheme="http://benvim.github.io/tags/assembly/"/>
    
  </entry>
  
  <entry>
    <title>冥冥天籁之音涤荡你我的心灵，红尘中还有谁能及？</title>
    <link href="http://benvim.github.io/2016/03/19/fo/"/>
    <id>http://benvim.github.io/2016/03/19/fo/</id>
    <published>2016-03-19T06:02:42.000Z</published>
    <updated>2016-03-19T06:12:05.000Z</updated>
    
    <content type="html">&lt;p&gt;　　如若我是来还债的，&lt;br&gt;　　那就尽量多还一些，&lt;br&gt;　　宁人负我，我不负人。&lt;br&gt;　　如若我是来报恩的，&lt;br&gt;　　那就尽量多报一些，&lt;br&gt;　　今生为人实属不易，&lt;br&gt;　　我要把人性发挥到极致。&lt;br&gt;　　&lt;br&gt;　　每当遭遇困境、&lt;br&gt;　　面对挫折、&lt;br&gt;　　感觉不被理解、&lt;br&gt;　　内心不能够平静时，&lt;br&gt;　　告诉自己：&lt;br&gt;　　今生已经是最后一生，&lt;br&gt;　　我将永远告别这个&lt;br&gt;　　娑婆世界，&lt;br&gt;　　没有什么值得长久计较。&lt;br&gt;　　虽一时之间&lt;br&gt;　　偶尔会有抵触与抱怨，&lt;br&gt;　　但我会很快&lt;br&gt;　　提醒自己保持正念觉知。&lt;br&gt;　　&lt;br&gt;　　人生再长，&lt;br&gt;　　不过百年，&lt;br&gt;　　这一生的岁月&lt;br&gt;　　只是我在这个空间的&lt;br&gt;　　一场梦幻。&lt;br&gt;　　不论如何活着，&lt;br&gt;　　快乐着或是痛苦着，&lt;br&gt;　　其实都是最有意义的一生，&lt;br&gt;　　值得自豪的一生，&lt;br&gt;　　值得珍惜的一生。&lt;br&gt;　　&lt;br&gt;　　今生。&lt;br&gt;　　将是我在娑婆世界的&lt;br&gt;　　最后一生，&lt;br&gt;　　这真是一件天大喜事。&lt;br&gt;　　当慧命在红尘历尽&lt;br&gt;　　劫难之后，&lt;br&gt;　　我终于可以回归&lt;br&gt;　　万有的源头。&lt;br&gt;　　那么，&lt;br&gt;　　还有什么值得抱怨、&lt;br&gt;　　唠叨、遗憾、&lt;br&gt;　　痛悔、嗔恨的呢？&lt;br&gt;　　&lt;br&gt;　　如果还有，&lt;br&gt;　　就是忘记了&lt;br&gt;　　“最后”这两个字，&lt;br&gt;　　或者是对“最后”&lt;br&gt;　　这两个字认识不够、&lt;br&gt;　　信心不够。&lt;br&gt;　　时时牢记着：&lt;br&gt;　　今生，&lt;br&gt;　　是我在红尘的最后一生！&lt;br&gt;　　再来时，我必脚踏莲花，&lt;br&gt;　　乘愿而来。来时凡夫，&lt;br&gt;　　回时必己超凡入圣！&lt;br&gt;　　人身难得今已得，&lt;br&gt;　　佛法难闻今已闻，&lt;br&gt;　　今生不借此身渡，&lt;br&gt;　　更待何生渡此身&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　如若我是来还债的，&lt;br&gt;　　那就尽量多还一些，&lt;br&gt;　　宁人负我，我不负人。&lt;br&gt;　　如若我是来报恩的，&lt;br&gt;　　那就尽量多报一些，&lt;br&gt;　　今生为人实属不易，&lt;br&gt;　　我要把人性发挥到极致。&lt;br&gt;　　&lt;br&gt;　　每当遭遇困境、&lt;br&gt;　　面对挫折、&lt;br
    
    </summary>
    
      <category term="碎碎念" scheme="http://benvim.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="http://benvim.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>shell命令的操作及命令的搜索</title>
    <link href="http://benvim.github.io/2016/03/12/shell-Oprate/"/>
    <id>http://benvim.github.io/2016/03/12/shell-Oprate/</id>
    <published>2016-03-12T00:50:07.000Z</published>
    <updated>2016-03-12T01:12:47.000Z</updated>
    
    <content type="html">&lt;p&gt;经常会使用shell对文件进行一些操作。但是命令行的操作不熟悉也是特别影响效率的，如何快速度的返回上一次目录，如何编辑当前命令行的内容对于提高效率是非常有帮助的。&lt;br&gt;你是否经常连续按“backSpace”键来删除当前的命令，是否为了返回上次目录而不断的“cd”,而又或者不断的按方向键去修改其中写错的某个单词…..这些土鳖的方向必须抛弃。&lt;/p&gt;
&lt;h3 id=&quot;回到上一次操作的目录&quot;&gt;&lt;a href=&quot;#回到上一次操作的目录&quot; class=&quot;headerlink&quot; title=&quot;回到上一次操作的目录&quot;&gt;&lt;/a&gt;回到上一次操作的目录&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;cd -
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;历史命令快捷键&quot;&gt;&lt;a href=&quot;#历史命令快捷键&quot; class=&quot;headerlink&quot; title=&quot;历史命令快捷键&quot;&gt;&lt;/a&gt;历史命令快捷键&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[Ctrl+r], [Ctrl+p], [Ctrl+n]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[Ctrl+r] 是搜索历史命令的，当使用这个组合键后，会出现个输入框，你每按一个字符都会自动从历史命令中匹配出相关结果，选择你要的按回车即可,该命令可以快速定位到你之前使用的任何命令，比如cd过哪个很长的目录。&lt;/p&gt;
&lt;p&gt;[Ctrl+p]和[Ctrl+n]主要功能是翻阅历史命令，上一条和下一条。此命令一般在最近使用过的命令比较方便。&lt;/p&gt;
&lt;h3 id=&quot;命令行内快速操作键&quot;&gt;&lt;a href=&quot;#命令行内快速操作键&quot; class=&quot;headerlink&quot; title=&quot;命令行内快速操作键&quot;&gt;&lt;/a&gt;命令行内快速操作键&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;移动操作快捷键&lt;br&gt;Ctrl + f– 向右移动一个字符，当然多数人用→&lt;br&gt;Ctrl + b– 向左移动一个字符， 多数人用←&lt;br&gt;ESC + f– 向右移动一个单词，MAC下建议用ALT + →&lt;br&gt;ESC + b– 向左移动一个单词，MAC下建议用ALT + ←&lt;br&gt;Ctrl + a– 跳到行首&lt;br&gt;Ctrl + e– 跳到行尾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除操作快捷键&lt;br&gt;Ctrl + d– 向右删除一个字符&lt;br&gt;Ctrl + h– 向左删除一个字符&lt;br&gt;Ctrl + u– 删除当前位置字符至行首（输入密码错误的时候多用下这个）&lt;br&gt;Ctrl + k– 删除当前位置字符至行尾&lt;br&gt;Ctrl + w– 删除从光标到当前单词开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他操作快捷键&lt;br&gt;Ctrl + y– 插入最近删除的单词&lt;br&gt;Ctrl + c– 终止操作&lt;br&gt;Ctrl + d– 当前操作转到后台&lt;br&gt;Ctrl + l– 清屏 （有时候为了好看）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用了这些快捷后，立马感觉神清气爽~。over.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;经常会使用shell对文件进行一些操作。但是命令行的操作不熟悉也是特别影响效率的，如何快速度的返回上一次目录，如何编辑当前命令行的内容对于提高效率是非常有帮助的。&lt;br&gt;你是否经常连续按“backSpace”键来删除当前的命令，是否为了返回上次目录而不断的“cd”,而又或者
    
    </summary>
    
      <category term="shell" scheme="http://benvim.github.io/categories/shell/"/>
    
    
      <category term="shell" scheme="http://benvim.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>AlphaGo VS Human</title>
    <link href="http://benvim.github.io/2016/03/10/Human/"/>
    <id>http://benvim.github.io/2016/03/10/Human/</id>
    <published>2016-03-10T00:19:34.000Z</published>
    <updated>2016-03-19T06:09:51.000Z</updated>
    
    <content type="html">&lt;p&gt;3月9日可能会成为写入人类史册的一天，一场世界上最会下围棋的人与人工智能的超级对弈，被全人类通过网络直播共同围观。谷歌董事长斯密特说，“输赢都是人类的胜利”。他这么说是因为李世石要迎战的不单是个机器人，而是这个世界上最聪明的霸道总裁和科学狂人们。&lt;/p&gt;
&lt;p&gt;AlphaGo机器人最厉害的地方，他不是一个机械的编码程序，他有一个“监督预判机制”，每走一步，他会考虑这种走法是不是更有前途，这是一种类似“想象力”的能力。这种思维模式，几乎和人类的直觉类似，使得他前所未有地更加像人类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;uploads/12.jpg&quot; alt=&quot;AlphaGo vs Human&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;3月9日可能会成为写入人类史册的一天，一场世界上最会下围棋的人与人工智能的超级对弈，被全人类通过网络直播共同围观。谷歌董事长斯密特说，“输赢都是人类的胜利”。他这么说是因为李世石要迎战的不单是个机器人，而是这个世界上最聪明的霸道总裁和科学狂人们。&lt;/p&gt;
&lt;p&gt;AlphaG
    
    </summary>
    
      <category term="闲聊" scheme="http://benvim.github.io/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="随记" scheme="http://benvim.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>東京日和</title>
    <link href="http://benvim.github.io/2016/03/08/%E6%9D%B1%E4%BA%AC%E6%97%A5%E5%92%8C/"/>
    <id>http://benvim.github.io/2016/03/08/東京日和/</id>
    <published>2016-03-08T03:57:59.000Z</published>
    <updated>2016-03-08T04:37:11.000Z</updated>
    
    <content type="html">&lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width: 100%;&quot;&gt;&lt;img src=&quot;/uploads/p2260354451.jpg&quot; alt=&quot;东京日和&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width: 33.333333333333336%;&quot;&gt;&lt;img src=&quot;/uploads/p2260498779.jpg&quot; alt=&quot;东京日和&quot;&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width: 33.333333333333336%;&quot;&gt;&lt;img src=&quot;/uploads/p2260498780.jpg&quot; alt=&quot;东京日和&quot;&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width: 33.333333333333336%;&quot;&gt;&lt;img src=&quot;/uploads/p2322111491.jpg&quot; alt=&quot;东京日和&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
</content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="album" scheme="http://benvim.github.io/categories/album/"/>
    
    
      <category term="美图" scheme="http://benvim.github.io/tags/%E7%BE%8E%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>言轻语长</title>
    <link href="http://benvim.github.io/2016/03/07/%E8%A8%80%E8%BD%BB%E8%AF%AD%E9%95%BF/"/>
    <id>http://benvim.github.io/2016/03/07/言轻语长/</id>
    <published>2016-03-07T12:53:50.000Z</published>
    <updated>2016-03-07T14:09:31.000Z</updated>
    
    <content type="html">&lt;p&gt;当意识再次醒来时，过去如同山崩之流，倾泻而来，将萌芽的光线拖入无尽的黑暗之中。挣脱之后，恍如昨日，一线之隔，南为乾坤，北为虚无。&lt;/p&gt;
&lt;p&gt;一把岁月，无尽悲伤，聚散离合皆付风中。不曾相遇，何曾相识；不曾相识，何曾相知；未曾相知，遑论感伤。如若初遇，不如不遇。于世之最大谎言在于问心无愧。&lt;/p&gt;
&lt;p&gt;风来雨去，日落月升，蓦然回首时物是人非。虚度彩练当空，徘徊庭树遍绿，长叹夕阳沉暮。不言问心无愧，只许一纸墨迹。&lt;/p&gt;
&lt;p&gt;言轻轻待摆渡，语长长候倾听。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;当意识再次醒来时，过去如同山崩之流，倾泻而来，将萌芽的光线拖入无尽的黑暗之中。挣脱之后，恍如昨日，一线之隔，南为乾坤，北为虚无。&lt;/p&gt;
&lt;p&gt;一把岁月，无尽悲伤，聚散离合皆付风中。不曾相遇，何曾相识；不曾相识，何曾相知；未曾相知，遑论感伤。如若初遇，不如不遇。于世之最大谎
    
    </summary>
    
    
      <category term="随笔" scheme="http://benvim.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>十年</title>
    <link href="http://benvim.github.io/2016/03/07/%E5%8D%81%E5%B9%B4/"/>
    <id>http://benvim.github.io/2016/03/07/十年/</id>
    <published>2016-03-07T12:51:39.000Z</published>
    <updated>2016-03-07T14:08:57.000Z</updated>
    
    <content type="html">&lt;p&gt;昨日之事已在风中冷却，明天的回忆会不会被忘却？我想在这黑暗的城市上空飞行，看看灯火里别人的故事是否也如此的彷徨？&lt;/p&gt;
&lt;p&gt;千家灯火万家难。望着他人的幸福，徒生向往；注目他人的难处，油然怜悯。他们时而欢笑，时而落泪。因为小事而倍感幸福，因为小事而万分感伤。&lt;/p&gt;
&lt;p&gt;那些绽放如花的笑容，那些泪洒如雨的忧伤，都随着时间的流逝或被遗忘，或被掩藏。万物皆无法摆脱时间的摆弄。时间是一个随意的雕刻家，雕塑着一幕幕的喜怒哀乐。&lt;/p&gt;
&lt;p&gt;一幕无人视，繁华一曲谁人听。半生浮萍，一世漂泊，肝肠寸断，所为几何？&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;昨日之事已在风中冷却，明天的回忆会不会被忘却？我想在这黑暗的城市上空飞行，看看灯火里别人的故事是否也如此的彷徨？&lt;/p&gt;
&lt;p&gt;千家灯火万家难。望着他人的幸福，徒生向往；注目他人的难处，油然怜悯。他们时而欢笑，时而落泪。因为小事而倍感幸福，因为小事而万分感伤。&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="随笔" scheme="http://benvim.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>开始码字生活</title>
    <link href="http://benvim.github.io/2016/03/07/test/"/>
    <id>http://benvim.github.io/2016/03/07/test/</id>
    <published>2016-03-07T05:59:30.000Z</published>
    <updated>2016-03-23T06:04:34.000Z</updated>
    
    <content type="html">&lt;p&gt;用VIM写文章不晓得会是一种什么样的体验&lt;/p&gt;
&lt;p&gt;发现个最大的问题就是输入法的切换问题，因为每次切换成VIM的正常模式，都要切换输入法，这是个很麻烦的操作，或许有更方法的操作我不晓得。&lt;/p&gt;
&lt;p&gt;$$\begin{array}{c|lcr}n&amp;amp;\text{Left}&amp;amp;\text{Center}&amp;amp;\text{Right}\\\hline1&amp;amp;0.24&amp;amp;1&amp;amp;125\\2&amp;amp;-1&amp;amp;189&amp;amp;-8\\3&amp;amp;-20&amp;amp;2000&amp;amp;1+10i\end{array}$$&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;用VIM写文章不晓得会是一种什么样的体验&lt;/p&gt;
&lt;p&gt;发现个最大的问题就是输入法的切换问题，因为每次切换成VIM的正常模式，都要切换输入法，这是个很麻烦的操作，或许有更方法的操作我不晓得。&lt;/p&gt;
&lt;p&gt;$$\begin{array}{c|lcr}n&amp;amp;\text{
    
    </summary>
    
      <category term="随记" scheme="http://benvim.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://benvim.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL数据库备份操作</title>
    <link href="http://benvim.github.io/2016/01/13/mysql-mysqldump/"/>
    <id>http://benvim.github.io/2016/01/13/mysql-mysqldump/</id>
    <published>2016-01-13T07:29:14.000Z</published>
    <updated>2016-03-20T16:01:22.000Z</updated>
    
    <content type="html">&lt;p&gt;用PHP语言进行MYSQL数据库备份操作。技术上需要的函数 &lt;em&gt;mysqldump&lt;/em&gt; 方法，该方法是 &lt;em&gt;MYSQL&lt;/em&gt; 的程序，所以需要指明该程序的地址，另外需要PHP语言的 &lt;em&gt;exec&lt;/em&gt;去执行该方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public function export(){
    $cfg_dbhost = C(&amp;quot;DB_HOST&amp;quot;);
    $cfg_dbuser = C(&amp;quot;DB_USER&amp;quot;);
    $cfg_dbpwd  = C(&amp;quot;DB_PWD&amp;quot;);
    $cfg_dbname = C(&amp;quot;DB_NAME&amp;quot;);

    $cfg_dbname = &amp;quot;cpk&amp;quot;;
    $filename=date(&amp;quot;Y-m-d_H-i-s&amp;quot;).&amp;quot;-&amp;quot;.$cfg_dbname.&amp;quot;.sql&amp;quot;; 
    // 所保存的文件名 
    header(&amp;quot;Content-disposition:filename=&amp;quot;.$filename); 
    header(&amp;quot;Content-type:application/octetstream&amp;quot;); 
    header(&amp;quot;Pragma:no-cache&amp;quot;); 
    header(&amp;quot;Expires:0&amp;quot;); 

    $tmpFile = $_SERVER[&amp;apos;DOCUMENT_ROOT&amp;apos;].$this-&amp;gt;path.$filename;// 获取当前页面文件路径，SQL文件就导出到此文件夹内 
    exec($this-&amp;gt;mysqlDumpPath.&amp;quot;mysqldump -u$cfg_dbuser -p$cfg_dbpwd -h$cfg_dbhost  $cfg_dbname &amp;gt; &amp;quot;.$tmpFile); 
    $file = fopen($tmpFile, &amp;quot;r&amp;quot;); // 打开文件 
    $info = fread($file,filesize($tmpFile));
    $this-&amp;gt;ajaxReturn(&amp;quot;0&amp;quot;, &amp;quot;备份完成&amp;quot;,&amp;quot;$filename&amp;quot;);
    fclose($file);
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;用PHP语言进行MYSQL数据库备份操作。技术上需要的函数 &lt;em&gt;mysqldump&lt;/em&gt; 方法，该方法是 &lt;em&gt;MYSQL&lt;/em&gt; 的程序，所以需要指明该程序的地址，另外需要PHP语言的 &lt;em&gt;exec&lt;/em&gt;去执行该方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 
    
    </summary>
    
      <category term="mysql" scheme="http://benvim.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://benvim.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>ssh连接缓慢解决方法</title>
    <link href="http://benvim.github.io/2016/01/09/cenos-ssh/"/>
    <id>http://benvim.github.io/2016/01/09/cenos-ssh/</id>
    <published>2016-01-09T12:12:05.000Z</published>
    <updated>2016-03-20T16:00:59.000Z</updated>
    
    <content type="html">&lt;p&gt;连接服务器的SSH服务的时候，等待输入密码的状态时间太长，要等很久。而且是局域网，并且PING的速度非常快，所以很有必要解决一下连接速度的问题了。&lt;/p&gt;
&lt;p&gt;下面说下如何解决这样的问题，最为常见的原因是因为server的sshd会去DNS查找访问client IP的hostname,如果DNS不可用或者没有相关记录，就会耗费大量时间。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在server上 &lt;em&gt;/etc/hosts&lt;/em&gt; 文件中把你本机的ip和hostname加入 &lt;/li&gt;
&lt;li&gt;在server上 &lt;em&gt;/etc/ssh/sshd_config&lt;/em&gt; 文件中修改或加入UseDNS=no，另外在 &lt;em&gt;authentication gssapi-with-mic&lt;/em&gt; 也有可能出现问题，在server上 &lt;em&gt;/etc/ssh/sshd_config&lt;/em&gt; 文件中修改GSSAPIAuthentication no.&lt;/li&gt;
&lt;li&gt;修改 &lt;em&gt;server上/etc/nsswitch.conf&lt;/em&gt; 中hosts为hosts： files&lt;/li&gt;
&lt;li&gt;reboot server使配置生效&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;※虽然配置文件中[UseDNS yes]被注释点，但默认开关就是yes…(SSH服务默认启用了DNS反向解析的功能)&lt;/p&gt;
&lt;p&gt;在目标服务器上有一个文件/etc/nsswitch.conf ，里面有如下一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hoosts:files dns
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这行的含义是对于访问的主机进行域名解析的顺序，是先访问file，也就是/etc/hosts文件，如果hosts中没有记录域名，则访问dns，进行域名解析，如果dns也无法访问，就会等待访问超时后返回，因此等待时间比较长。&lt;/p&gt;
&lt;p&gt;那如果将这一行屏蔽掉是不是也可以达到同样的效果呢？应该是可以的，但是如果本机要通过域名访问其他服务器，则肯定无法访问，因此这行应该需要保留。这个问题也提示我们，dns如果不可用，会带来的一些副作用的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;连接服务器的SSH服务的时候，等待输入密码的状态时间太长，要等很久。而且是局域网，并且PING的速度非常快，所以很有必要解决一下连接速度的问题了。&lt;/p&gt;
&lt;p&gt;下面说下如何解决这样的问题，最为常见的原因是因为server的sshd会去DNS查找访问client IP的ho
    
    </summary>
    
      <category term="linux" scheme="http://benvim.github.io/categories/linux/"/>
    
    
      <category term="centos" scheme="http://benvim.github.io/tags/centos/"/>
    
      <category term="ssh" scheme="http://benvim.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>PHP关于时间的问题，今天、昨天、前天、最近7天，最近30天</title>
    <link href="http://benvim.github.io/2015/12/29/php-time/"/>
    <id>http://benvim.github.io/2015/12/29/php-time/</id>
    <published>2015-12-29T02:20:34.000Z</published>
    <updated>2016-03-20T16:00:53.000Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;获取日期&lt;/li&gt;
&lt;li&gt;获取日期时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经常会用到时间查询之类问题，直接获取天日期由以下方法即可达到。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;今天:&amp;quot;.date(&amp;quot;Y-m-d&amp;quot;).&amp;quot;&amp;lt;br&amp;gt;&amp;quot;;     
echo &amp;quot;今天:&amp;quot;.date(&amp;quot;Y-m-d&amp;quot;).&amp;quot;&amp;lt;br&amp;gt;&amp;quot;;     
echo &amp;quot;今天:&amp;quot;.date(&amp;quot;Y-m-d&amp;quot;).&amp;quot;&amp;lt;br&amp;gt;&amp;quot;;     
echo &amp;quot;昨天:&amp;quot;.date(&amp;quot;Y-m-d&amp;quot;,strtotime(&amp;quot;-1 day&amp;quot;)), &amp;quot;&amp;lt;br&amp;gt;&amp;quot;; 
echo &amp;quot;前天:&amp;quot;.date(&amp;quot;Y-m-d&amp;quot;,strtotime(&amp;quot;-2 day&amp;quot;)), &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
echo &amp;quot;最近30天：&amp;quot;.date(&amp;quot;Y-m-d&amp;quot;,strtotime(&amp;quot;-30 day&amp;quot;)), &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;获取日期&lt;/li&gt;
&lt;li&gt;获取日期时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经常会用到时间查询之类问题，直接获取天日期由以下方法即可达到。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;今天:&amp;quot;.date(&amp;quot;Y-m-d&amp;quot;).&amp;quo
    
    </summary>
    
      <category term="php" scheme="http://benvim.github.io/categories/php/"/>
    
    
      <category term="php" scheme="http://benvim.github.io/tags/php/"/>
    
      <category term="time" scheme="http://benvim.github.io/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>AWS中Centos创建后登录以及修改密码配置</title>
    <link href="http://benvim.github.io/2015/12/23/centos-aws/"/>
    <id>http://benvim.github.io/2015/12/23/centos-aws/</id>
    <published>2015-12-23T11:22:43.000Z</published>
    <updated>2016-03-20T13:38:58.000Z</updated>
    
    <content type="html">&lt;p&gt;根据AWS中的文档，创建并启动实例后，使用pem密钥进行登录系统，但是使用的是centos用户登录，权限受限，可以使用sudo提升权限进行安装、删除软件，除此之外我们还需要修改root的密码，方便系统管理。修改方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo passwd root
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;系统会提示输入密码和确认密码，就修改完成。然后使用su切换成root用户，输入密码即切换成root用户了。&lt;/p&gt;
&lt;h4 id=&quot;修改centos登录方式为密码登录&quot;&gt;&lt;a href=&quot;#修改centos登录方式为密码登录&quot; class=&quot;headerlink&quot; title=&quot;修改centos登录方式为密码登录&quot;&gt;&lt;/a&gt;修改centos登录方式为密码登录&lt;/h4&gt;&lt;p&gt;打开配置文件 /etc/ssh/sshd_config (ubuntu 为/etc/ssh/sshd-config)，设置如下几个参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PermitRootLogin yes
PubkeyAuthentication no #（也可用#号注释）
PasswordAuthentication yes
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;重启sshd服务&quot;&gt;&lt;a href=&quot;#重启sshd服务&quot; class=&quot;headerlink&quot; title=&quot;重启sshd服务&quot;&gt;&lt;/a&gt;重启sshd服务&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;/etc/init.d/sshd restart
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;根据AWS中的文档，创建并启动实例后，使用pem密钥进行登录系统，但是使用的是centos用户登录，权限受限，可以使用sudo提升权限进行安装、删除软件，除此之外我们还需要修改root的密码，方便系统管理。修改方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo passwd
    
    </summary>
    
      <category term="linux" scheme="http://benvim.github.io/categories/linux/"/>
    
    
      <category term="aws" scheme="http://benvim.github.io/tags/aws/"/>
    
      <category term="linux" scheme="http://benvim.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Centos配置国内yum源</title>
    <link href="http://benvim.github.io/2015/12/20/centos-yum/"/>
    <id>http://benvim.github.io/2015/12/20/centos-yum/</id>
    <published>2015-12-20T02:00:12.000Z</published>
    <updated>2016-03-20T13:17:06.000Z</updated>
    
    <content type="html">&lt;p&gt;网易（163）yum源是国内最好的yum源之一，无论是速度还是软件版本，都非常的不错，将yum源设置为163yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到。具体设置方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进入yum源配置目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /etc/yum.repos.d
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;备份系统自带的yum源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mv CentOS-Base.repo CentOS-Base.repo.bk #下载163网易的yum源：
wget http://mirrors.163.com/.help/CentOS6-Base-163.repo
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更新玩yum源后，执行下边命令更新yum配置，使操作立即生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum makecache
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除了网易之外，国内还有其他不错的yum源，比如中科大和搜狐的，大家可以根据自己需求下载&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中科大的yum源：&lt;/li&gt;
&lt;li&gt;sohu的yum源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;wget &lt;a href=&quot;http://centos.ustc.edu.cn/CentOS-Base.repo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://centos.ustc.edu.cn/CentOS-Base.repo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;wget &lt;a href=&quot;http://mirrors.sohu.com/help/CentOS-Base-sohu.repo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mirrors.sohu.com/help/CentOS-Base-sohu.repo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理论上讲，这些yum源redhat系统以及fedora也是可以用的，但是没有经过测试，需要的站长可以自己测试一下。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;网易（163）yum源是国内最好的yum源之一，无论是速度还是软件版本，都非常的不错，将yum源设置为163yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到。具体设置方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进入yum源配置目录&lt;/p&gt;
&lt;pre&gt;
    
    </summary>
    
      <category term="linux" scheme="http://benvim.github.io/categories/linux/"/>
    
    
      <category term="centos" scheme="http://benvim.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式替换图片格式</title>
    <link href="http://benvim.github.io/2015/12/10/php-reg/"/>
    <id>http://benvim.github.io/2015/12/10/php-reg/</id>
    <published>2015-12-10T06:12:00.000Z</published>
    <updated>2016-03-20T16:00:39.000Z</updated>
    
    <content type="html">&lt;p&gt;项目中需要对现有的用户发表的详情图片展示功能增加点击放大预览的效果。查看代码：现有代码逻辑为上传图片，生成最大宽600像素以内和最大高400像素以内的缩略图，并删除原图。所以修改该代码，上传图片生成600x400像素的缩略图，并保留原图以备点击放大使用。&lt;/p&gt;
&lt;p&gt;使用的jquery插件&lt;a href=&quot;http://www.helloweba.com/view-blog-65.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;fancybox&lt;/a&gt;。Fancybox是一款优秀的jquery插件，它能够展示丰富的弹出层效果。前面我们有文章介绍了facybox弹出层效果，相比facybox，fancybox显得功能更为齐全，它除了可以加载DIV，图片、图片集、Ajax数据，还能加载SWF影片，iframe页面等等&lt;/p&gt;
&lt;h3 id=&quot;fancybox具有以下特性：&quot;&gt;&lt;a href=&quot;#fancybox具有以下特性：&quot; class=&quot;headerlink&quot; title=&quot;fancybox具有以下特性：&quot;&gt;&lt;/a&gt;fancybox具有以下特性：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可以加载DIV、图片、图片集、Ajax数据、SWF影片，iframe页面等。&lt;/li&gt;
&lt;li&gt;支持键盘方向键和ESC键。&lt;/li&gt;
&lt;li&gt;丰富的参数设置和方法调用。&lt;/li&gt;
&lt;li&gt;可扩展性强.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基本的代码如下：&quot;&gt;&lt;a href=&quot;#基本的代码如下：&quot; class=&quot;headerlink&quot; title=&quot;基本的代码如下：&quot;&gt;&lt;/a&gt;基本的代码如下：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**
* 对投稿者上交的稿件描述内容的图片增加点击放大功能;
* 1.匹配所有相关的项，找出描述中上传的图片;
* 2.遍历数组，找到图形中的src.并保存到$res中;
* 3.对src值进行查询替换，改装成正则表达式。对元字符做转义;
* 4.用改装的正则去匹配并替换格式化的IMG地址;
* @param string $str 需要遍历并替换的文本
* @return string $str 替换处理过的文本  
*/
private function taskManuscriptInfoImagesOperate($str){
    preg_match_all(&amp;apos;/&amp;lt;\s*img\s+[^&amp;gt;]*?src\s*=\s*(\&amp;apos;|\&amp;quot;)(.*?)\\1[^&amp;gt;]*?\/?\s*&amp;gt;/i&amp;apos;,$str,$match);
    foreach ($match[0] as $key =&amp;gt; $value) {
    preg_match(&amp;quot;/\/data\/upload\/editer\/image\/.*g/&amp;quot;, $value, $res);
    $r = preg_replace(&amp;quot;/\//&amp;quot;, &amp;quot;\\/&amp;quot;, $res);
    $r = preg_replace(&amp;quot;/\./&amp;quot;, &amp;quot;\\.&amp;quot;, $r);
    $str = preg_replace(&amp;quot;/&amp;lt;\s*img\s+[^&amp;gt;]*?src\s*=\s*(\&amp;apos;|\&amp;quot;)(&amp;quot;.$r[0].&amp;quot;)\\1[^&amp;gt;]*?\/?\s*&amp;gt;/i&amp;quot;, $this-&amp;gt;formatURL($res[0]), $str);
    }
    return $str;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该函数中的perg_match_all函数是PHP正则匹配多次的函数。并通过正则查找字符串中的图片。该函数返回的是一个数组，匹配结果中可能会有1个或多个图片对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;preg_match_all(&amp;apos;/&amp;lt;\s*img\s+[^&amp;gt;]*?src\s*=\s*(\&amp;apos;|\&amp;quot;)(.*?)\\1[^&amp;gt;]*?\/?\s*&amp;gt;/i&amp;apos;,$str,$match);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;找出每个图片IMG标签中的SRC值，并用formatURL()方法重新生成符合&lt;a href=&quot;http://www.helloweba.com/view-blog-65.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;fancybox&lt;/a&gt;的语法格式的字符串，并通过匹配查询并替换现有的图片代码块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;preg_match(&amp;quot;/\/data\/upload\/editer\/image\/.*g/&amp;quot;, $value, $res);//找出SRC值
$r = preg_replace(&amp;quot;/\//&amp;quot;, &amp;quot;\\/&amp;quot;, $res);//把SRC值的字符进行替换，以符合正则规则。
$r = preg_replace(&amp;quot;/\./&amp;quot;, &amp;quot;\\.&amp;quot;, $r);
$str = preg_replace(&amp;quot;/&amp;lt;\s*img\s+[^&amp;gt;]*?src\s*=\s*(\&amp;apos;|\&amp;quot;)(&amp;quot;.$r[0].&amp;quot;)\\1[^&amp;gt;]*?\/?\s*&amp;gt;/i&amp;quot;, $this-&amp;gt;formatURL($res[0]), $str);//查找并替换
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;格式化地址代码如下：使用匹配出来的图片地址，生成新的图片地址信息，符合&lt;a href=&quot;http://www.helloweba.com/view-blog-65.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;fancybox&lt;/a&gt;的要求格式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 格式化地址
* @return [type] [description]
*/
private function formatURL($url){
    $name = basename($url);
    $path = dirname($url);
    $arr  = explode(&amp;quot;_&amp;quot;, $name);
    $len  = count($arr);
    $html = &amp;quot;&amp;quot;;
    if($len&amp;gt;2 || $len==1){
        $html = &amp;quot;&amp;lt;a rel=&amp;apos;group&amp;apos; href=&amp;apos;&amp;quot;.$url.&amp;quot;&amp;apos;&amp;gt;&amp;lt;img src=&amp;apos;&amp;quot;.$url.&amp;quot;&amp;apos;&amp;gt;&amp;lt;/a&amp;gt;&amp;quot;; //兼容老地址。
    }else if($len&amp;gt;1){
        $p = $arr[1];
        $p = explode(&amp;quot;?&amp;quot;, $p);
        if (count($p)&amp;gt;1){$p = $p[0];}
        $u = $path.&amp;quot;/&amp;quot;.$p[0];
        $char = substr($u, 0, 1 );
        if($char==&amp;quot;/&amp;quot;){$u = substr($u,1,(strlen($u)-1));}
        if(file_exists($u)){
            $html = &amp;quot;&amp;lt;a rel=&amp;apos;group&amp;apos; href=&amp;apos;/&amp;quot;.$u.&amp;quot;&amp;apos;&amp;gt;&amp;lt;img src=&amp;apos;&amp;quot;.$url.&amp;quot;&amp;apos;&amp;gt;&amp;lt;/a&amp;gt;&amp;quot;;
            }else{
            $html = &amp;quot;&amp;lt;a rel=&amp;apos;group&amp;apos; href=&amp;apos;&amp;quot;.$url.&amp;quot;&amp;apos;&amp;gt;&amp;lt;img src=&amp;apos;&amp;quot;.$url.&amp;quot;&amp;apos;&amp;gt;&amp;lt;/a&amp;gt;&amp;quot;;
            }
    }
    return $html;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;总的思路就是查找图片，找出图片地址，用地址生成新的格式，然后再用地址匹配并用新的格式替换老的图片代码块。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;项目中需要对现有的用户发表的详情图片展示功能增加点击放大预览的效果。查看代码：现有代码逻辑为上传图片，生成最大宽600像素以内和最大高400像素以内的缩略图，并删除原图。所以修改该代码，上传图片生成600x400像素的缩略图，并保留原图以备点击放大使用。&lt;/p&gt;
&lt;p&gt;使用
    
    </summary>
    
      <category term="php" scheme="http://benvim.github.io/categories/php/"/>
    
    
      <category term="php" scheme="http://benvim.github.io/tags/php/"/>
    
      <category term="fancybox" scheme="http://benvim.github.io/tags/fancybox/"/>
    
  </entry>
  
  <entry>
    <title>财务数值表示法</title>
    <link href="http://benvim.github.io/2015/11/28/php-numberformat/"/>
    <id>http://benvim.github.io/2015/11/28/php-numberformat/</id>
    <published>2015-11-28T06:19:00.000Z</published>
    <updated>2016-03-20T16:01:46.000Z</updated>
    
    <content type="html">&lt;p&gt;类似这样的： &lt;em&gt;￥97,709.99元&lt;/em&gt; 保留两位小数并且千位分隔。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//财务四舍五入保留两位小数。
function getPrecisionNumber($cash, $type=&amp;quot;0&amp;quot;){
    $cash = round($cash, 2);
    $cash = number_format($cash, 2, &amp;apos;.&amp;apos;, &amp;quot;,&amp;quot;);
    if(!$type){
        $cash = &amp;quot;￥&amp;quot;.$cash.&amp;quot;元&amp;quot;;
    }
    return $cash;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于财务要求高精度对帐， 所以要使用round进行四舍五入后的值来显示，本身数据是7位小数点的高精度值。使用 &lt;em&gt;number_format&lt;/em&gt; 方法格式化数值对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;number_format() 函数通过千位分组来格式化数字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注释：该函数支持一个、两个或四个参数（不是三个）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;number_format(number,decimals,decimalpoint,separator)
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;必需。要格式化的数字。&lt;br&gt;如果未设置其他参数，则数字会被格式化为不带小数点且以逗号（,）作为千位分隔符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decimals&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可选。规定多少个小数。如果设置了该参数，则使用点号（.）作为小数点来格式化数字。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decimalpoint&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可选。规定用作小数点的字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;separator&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可选。规定用作千位分隔符的字符串。仅使用该参数的第一个字符。比如 “xxx” 仅输出 “x”。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注释：如果设置了该参数，那么所有其他参数都是必需的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;类似这样的： &lt;em&gt;￥97,709.99元&lt;/em&gt; 保留两位小数并且千位分隔。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//财务四舍五入保留两位小数。
function getPrecisionNumber($cash, $type=&amp;quot;0&amp;quot;){
    $ca
    
    </summary>
    
      <category term="php" scheme="http://benvim.github.io/categories/php/"/>
    
    
      <category term="php" scheme="http://benvim.github.io/tags/php/"/>
    
      <category term="number_format" scheme="http://benvim.github.io/tags/number-format/"/>
    
  </entry>
  
  <entry>
    <title>生成appkey和appSecret</title>
    <link href="http://benvim.github.io/2015/11/17/php-appSecret/"/>
    <id>http://benvim.github.io/2015/11/17/php-appSecret/</id>
    <published>2015-11-17T12:54:01.000Z</published>
    <updated>2016-03-20T14:36:03.000Z</updated>
    
    <content type="html">&lt;p&gt;通常情况下，这种很长一段数字字母的key和secret都是通过md5和sha1加密算法来生成的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;appkey的生成&lt;/p&gt;
&lt;p&gt; appkey生成比较简单，一般是客户的唯一值+字符串组成，方法很多，做到唯一性的字符串就可以。比如使用用户的uid+”abc”字符串组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;appSecret生成方法&lt;/p&gt;
&lt;p&gt; 其原始数据有可能是你的账号的id，还有注册时间之类的唯一值进行组合再通过md5和sha1来生成，而md5和sha1对比的话，md5比sha1更快，但sha1比md5强度更高，所以在此类授权应用里，通常都使用sha1算法，例如oauth的签名算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;验证授权&lt;/p&gt;
&lt;p&gt; 例如要和微信通信里，要传递三个参数ABC，则需要将ABC与appsecret一起sha1一遍，得到一个签名串，然后将这个签名串与appkey一起传递给微信，&lt;br&gt;此时，微信会通过appkey去查找对应的appsecret，然后再将ABC参数与查询出来的appsecret做一遍相同的签名算法，如果得到的签名串一致，则认为是授权成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如下的代码可以参考：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public function  test(){
    if(!isset($_GET[&amp;apos;token&amp;apos;])){
        $this-&amp;gt;apiReturn(4001,&amp;apos;invalid token&amp;apos;);
    }else if(!S($_GET[&amp;apos;token&amp;apos;])){            
        $this-&amp;gt;apiReturn(4001,&amp;apos;invalid token&amp;apos;); 
    }
    $data = array(
    &amp;apos;id&amp;apos;=&amp;gt;2,
    &amp;apos;username&amp;apos;=&amp;gt;&amp;apos;明之暗夜&amp;apos;,
    &amp;apos;info&amp;apos;=&amp;gt;array(&amp;apos;age&amp;apos;=&amp;gt;24,&amp;apos;address&amp;apos;=&amp;gt;&amp;apos;学府路&amp;apos;,&amp;apos;url&amp;apos;=&amp;gt;&amp;apos;http://cnblogs.com/dmm888&amp;apos;));
    if($data){
    $this-&amp;gt;apiReturn(200,&amp;apos;读取用户信息成功&amp;apos;,$data,xml);
    }
}

public function getToken(){
    $ori_str = S($this-&amp;gt;appid.&amp;apos;_&amp;apos;.$this-&amp;gt;appsecret);
    //这里appid和appsecret我写固定了，实际是通过客户端获取  所以这里我们可以做很多 比如判断appid和appsecret有效性等
    if($ori_str){//重新获取就把以前的token删除
        S($ori_str,null);
    }

    //这里是token产生的机制  您也可以自己定义
    $nonce = $this-&amp;gt;createNoncestr(32);
    $tmpArr = array($nonce,$this-&amp;gt;appid,$this-&amp;gt;appsecret);

    sort($tmpArr, SORT_STRING);
    $tmpStr = implode( $tmpArr );
    $tmpStr = sha1( $tmpStr );
    // echo $tmpStr;
    //这里做了缓存 &amp;apos;a&amp;apos;=&amp;gt;b 和&amp;apos;b&amp;apos;=&amp;gt;a格式的缓存
    S($this-&amp;gt;appid.&amp;apos;_&amp;apos;.$this-&amp;gt;appsecret,$tmpStr,7200);  
    S($tmpStr,$this-&amp;gt;appid.&amp;apos;_&amp;apos;.$this-&amp;gt;appsecret,7200);
}
/**
* 作用：产生随机字符串，不长于32位
*/
function createNoncestr( $length = 32 ) 
{
    $chars = &amp;quot;abcdefghijklmnopqrstuvwxyz0123456789&amp;quot;;              $str =&amp;quot;&amp;quot;;
    for ( $i = 0; $i &amp;lt; $length; $i++ )  {  
        $str.= substr($chars, mt_rand(0, strlen($chars)-1), 1);
    }  
    return $str;
}     
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;通常情况下，这种很长一段数字字母的key和secret都是通过md5和sha1加密算法来生成的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;appkey的生成&lt;/p&gt;
&lt;p&gt; appkey生成比较简单，一般是客户的唯一值+字符串组成，方法很多，做到唯一性的字符串就可以。比如使用用户的u
    
    </summary>
    
      <category term="php" scheme="http://benvim.github.io/categories/php/"/>
    
    
      <category term="php" scheme="http://benvim.github.io/tags/php/"/>
    
      <category term="appSecret" scheme="http://benvim.github.io/tags/appSecret/"/>
    
  </entry>
  
</feed>
